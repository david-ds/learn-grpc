// Code generated by protoc-gen-go. DO NOT EDIT.
// source: todo.proto

/*
Package todo is a generated protocol buffer package.

It is generated from these files:
	todo.proto

It has these top-level messages:
	Task
	Text
	Void
	TaskList
*/
package todo

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Task struct {
	Title string `protobuf:"bytes,1,opt,name=title" json:"title,omitempty"`
	Done  bool   `protobuf:"varint,2,opt,name=done" json:"done,omitempty"`
}

func (m *Task) Reset()                    { *m = Task{} }
func (m *Task) String() string            { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()               {}
func (*Task) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Task) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Task) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

type Text struct {
	Text string `protobuf:"bytes,1,opt,name=text" json:"text,omitempty"`
}

func (m *Text) Reset()                    { *m = Text{} }
func (m *Text) String() string            { return proto.CompactTextString(m) }
func (*Text) ProtoMessage()               {}
func (*Text) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Text) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type Void struct {
}

func (m *Void) Reset()                    { *m = Void{} }
func (m *Void) String() string            { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()               {}
func (*Void) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type TaskList struct {
	Tasks []*Task `protobuf:"bytes,1,rep,name=tasks" json:"tasks,omitempty"`
}

func (m *TaskList) Reset()                    { *m = TaskList{} }
func (m *TaskList) String() string            { return proto.CompactTextString(m) }
func (*TaskList) ProtoMessage()               {}
func (*TaskList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *TaskList) GetTasks() []*Task {
	if m != nil {
		return m.Tasks
	}
	return nil
}

func init() {
	proto.RegisterType((*Task)(nil), "todo.Task")
	proto.RegisterType((*Text)(nil), "todo.Text")
	proto.RegisterType((*Void)(nil), "todo.Void")
	proto.RegisterType((*TaskList)(nil), "todo.TaskList")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AddService service

type AddServiceClient interface {
	Add(ctx context.Context, in *Text, opts ...grpc.CallOption) (*Task, error)
}

type addServiceClient struct {
	cc *grpc.ClientConn
}

func NewAddServiceClient(cc *grpc.ClientConn) AddServiceClient {
	return &addServiceClient{cc}
}

func (c *addServiceClient) Add(ctx context.Context, in *Text, opts ...grpc.CallOption) (*Task, error) {
	out := new(Task)
	err := grpc.Invoke(ctx, "/todo.AddService/Add", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AddService service

type AddServiceServer interface {
	Add(context.Context, *Text) (*Task, error)
}

func RegisterAddServiceServer(s *grpc.Server, srv AddServiceServer) {
	s.RegisterService(&_AddService_serviceDesc, srv)
}

func _AddService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Text)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/todo.AddService/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddServiceServer).Add(ctx, req.(*Text))
	}
	return interceptor(ctx, in, info, handler)
}

var _AddService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "todo.AddService",
	HandlerType: (*AddServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _AddService_Add_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "todo.proto",
}

// Client API for ListService service

type ListServiceClient interface {
	List(ctx context.Context, in *Void, opts ...grpc.CallOption) (*TaskList, error)
}

type listServiceClient struct {
	cc *grpc.ClientConn
}

func NewListServiceClient(cc *grpc.ClientConn) ListServiceClient {
	return &listServiceClient{cc}
}

func (c *listServiceClient) List(ctx context.Context, in *Void, opts ...grpc.CallOption) (*TaskList, error) {
	out := new(TaskList)
	err := grpc.Invoke(ctx, "/todo.ListService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ListService service

type ListServiceServer interface {
	List(context.Context, *Void) (*TaskList, error)
}

func RegisterListServiceServer(s *grpc.Server, srv ListServiceServer) {
	s.RegisterService(&_ListService_serviceDesc, srv)
}

func _ListService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/todo.ListService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListServiceServer).List(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

var _ListService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "todo.ListService",
	HandlerType: (*ListServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _ListService_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "todo.proto",
}

// Client API for DoneService service

type DoneServiceClient interface {
	Done(ctx context.Context, in *Text, opts ...grpc.CallOption) (*TaskList, error)
}

type doneServiceClient struct {
	cc *grpc.ClientConn
}

func NewDoneServiceClient(cc *grpc.ClientConn) DoneServiceClient {
	return &doneServiceClient{cc}
}

func (c *doneServiceClient) Done(ctx context.Context, in *Text, opts ...grpc.CallOption) (*TaskList, error) {
	out := new(TaskList)
	err := grpc.Invoke(ctx, "/todo.DoneService/Done", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DoneService service

type DoneServiceServer interface {
	Done(context.Context, *Text) (*TaskList, error)
}

func RegisterDoneServiceServer(s *grpc.Server, srv DoneServiceServer) {
	s.RegisterService(&_DoneService_serviceDesc, srv)
}

func _DoneService_Done_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Text)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DoneServiceServer).Done(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/todo.DoneService/Done",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DoneServiceServer).Done(ctx, req.(*Text))
	}
	return interceptor(ctx, in, info, handler)
}

var _DoneService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "todo.DoneService",
	HandlerType: (*DoneServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Done",
			Handler:    _DoneService_Done_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "todo.proto",
}

// Client API for DropService service

type DropServiceClient interface {
	Drop(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
}

type dropServiceClient struct {
	cc *grpc.ClientConn
}

func NewDropServiceClient(cc *grpc.ClientConn) DropServiceClient {
	return &dropServiceClient{cc}
}

func (c *dropServiceClient) Drop(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/todo.DropService/Drop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DropService service

type DropServiceServer interface {
	Drop(context.Context, *Void) (*Void, error)
}

func RegisterDropServiceServer(s *grpc.Server, srv DropServiceServer) {
	s.RegisterService(&_DropService_serviceDesc, srv)
}

func _DropService_Drop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DropServiceServer).Drop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/todo.DropService/Drop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DropServiceServer).Drop(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

var _DropService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "todo.DropService",
	HandlerType: (*DropServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Drop",
			Handler:    _DropService_Drop_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "todo.proto",
}

func init() { proto.RegisterFile("todo.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 225 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x90, 0x41, 0x4b, 0xc3, 0x40,
	0x14, 0x84, 0x89, 0xdd, 0x96, 0x3a, 0x01, 0x0f, 0x8b, 0x87, 0x10, 0x50, 0x96, 0x3d, 0x05, 0xd4,
	0xa2, 0xf1, 0x17, 0x14, 0x7a, 0xf4, 0x14, 0x8b, 0xf7, 0xea, 0xbe, 0xc3, 0x52, 0xe9, 0x2b, 0xd9,
	0x87, 0xe4, 0xe7, 0xcb, 0xdb, 0x36, 0x98, 0x7a, 0x9b, 0x61, 0xe6, 0x7b, 0xb3, 0x2c, 0x20, 0x1c,
	0x78, 0x75, 0xec, 0x59, 0xd8, 0x1a, 0xd5, 0xfe, 0x19, 0x66, 0xbb, 0x4b, 0x7b, 0x7b, 0x8b, 0xb9,
	0x44, 0xf9, 0xa6, 0xaa, 0x70, 0x45, 0x73, 0xdd, 0x9d, 0x8c, 0xb5, 0x30, 0x81, 0x0f, 0x54, 0x5d,
	0xb9, 0xa2, 0x59, 0x76, 0x59, 0xfb, 0x1a, 0x66, 0x4b, 0x83, 0x68, 0x26, 0x34, 0xc8, 0x19, 0xc8,
	0xda, 0x2f, 0x60, 0x3e, 0x38, 0x06, 0xff, 0x88, 0xa5, 0x5e, 0x7d, 0x8b, 0x49, 0xac, 0xc3, 0x5c,
	0x76, 0x69, 0x9f, 0xaa, 0xc2, 0xcd, 0x9a, 0xb2, 0xc5, 0x2a, 0xbf, 0x41, 0xe3, 0xee, 0x14, 0xb4,
	0x0f, 0xc0, 0x3a, 0x84, 0x77, 0xea, 0x7f, 0xe2, 0x17, 0xd9, 0x3b, 0xcc, 0xd6, 0x21, 0xd8, 0xb1,
	0x47, 0x83, 0xd4, 0x13, 0xa6, 0x7d, 0x41, 0xa9, 0x67, 0xc7, 0xb6, 0x87, 0xc9, 0x2b, 0xe7, 0x8a,
	0xae, 0xd7, 0x37, 0x7f, 0x75, 0xcd, 0x14, 0xd9, 0xf0, 0x81, 0x26, 0x88, 0xda, 0x8b, 0x85, 0xff,
	0xc8, 0x13, 0xca, 0x4d, 0xcf, 0xc7, 0x11, 0xb9, 0x87, 0x51, 0x7b, 0xb1, 0x32, 0xd1, 0x9f, 0x8b,
	0xfc, 0xa5, 0xaf, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x7d, 0x25, 0xdf, 0xce, 0x60, 0x01, 0x00,
	0x00,
}
